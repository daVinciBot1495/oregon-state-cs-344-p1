#!/bin/bash

# Initialize the variables used to store the input in a matrix. Note that the
# matrix is actually a single array and the data is arranged in row-major
# order.
typeset -i num_rows=0
typeset -i num_cols=0
typeset -a matrix_array=()

# Initialize the variables used to store the averages and medians
typeset -a averages=()

# Prints the usage message to stderr and exits with a status code of 1
usage() {
    echo "Usage: `basename $0` {-rows|-cols} [file]" >&2
    exit 1
}

# Reads the given file into matrix_array, sets num_rows, and sets num_cols
read_matrix() {
    # Since the matrix should be arranged in row-major order only the index
    # where data should be inserted next needs to be maintained
    local -i index=0

    # For each line in the file
    while read line; do
        # Initialize the number of columns to 0 since this has not been
        # determined yet
        num_cols=0

        # Split the line by tabs using the cut command and iterate through each
        # column value
        for col_value in $(echo $line | cut -f 1-); do
            # Convert the column value to an integer
            local -i col_value_int=$col_value

            # Insert the column value into the matrix
            matrix_array[index]=$col_value_int

            # Increment the index so that the next column value is inserted
            # into the correct location in the matrix
            (( index++ ))

            # Increment the number of columns. Note that this done for every
            # line. This is okay since it is assumed that every line has the
            # same number of columns. After the final line is processed the
            # number of columns will be correctly set.
            (( num_cols++ ))
        done

        # Increment the number of rows. After the final line is processed the
        # number of rows will be correctly set.
        (( num_rows++ ))
    done < $1
}

# Calculate the row averages of the matrix.
calc_row_averages() {
    # Clear the averages array
    averages=()

    for ((row=0;row<num_rows;++row)); do
        local -i row_sum=0

        for ((col=0;col<num_cols;++col)); do
            # Compute the index of the value at (row, col) in the matrix
            local -i index=$(( row * num_cols + col ))

            # Get the value at (row, col) in the matrix and add it to the row
            # sum
            row_sum+=${matrix_array[index]}
        done

        # Insert the row average into the averages array. Conceptually, the row
        # average is just the sum of the row elements divided by the number of
        # columns. However, in bash scripting only integer division is
        # performed. Hence, in order to round the average to the nearest whole
        # number the number of columns divided by two is added to the row sum
        # prior to dividing by the number of columns.
        averages[row]=$(( (row_sum + num_cols / 2) / num_cols ))
    done
}

# Calculates the column averages of the matrix.
calc_col_averages() {
    # Clear the averages array
    averages=()

    for ((col=0;col<num_cols;++col)); do
        local -i col_sum=0

        for ((row=0;row<num_rows;++row)); do
            # Compute the index of the value at (row, col) in the matrix
            local -i index=$(( row * num_cols + col ))

            # Get the value at (row, col) in the matrix and add it to the col
            # sum
            col_sum+=${matrix_array[index]}
        done

        # Insert the column average into the averages array similar to how
        # it's done for a row average.
        averages[col]=$(( (col_sum + num_rows / 2) / num_rows ))
    done
}

# Writes matrix_array to stdout
print_matrix() {
    local -i local_num_rows=$1
    local -i local_num_cols=$2
    local local_matrix_ref=$3[@]
    local -a local_matrix_array=("${!local_matrix_ref}")

    for ((row=0;row<local_num_rows;++row)); do
        for ((col=0;col<local_num_cols;++col)); do
            # Compute the index of the value at (row, col) in the matrix
            local -i index=$(( row * local_num_cols + col ))

            # Get the value at (row, col) in the matrix
            local -i value=${local_matrix_array[index]}

            # If the value is in the last column of the matrix then echo it
            # with a new line character after it. Otherwise, echo the value
            # with a tab character after it.
            if [[ $col -eq $(( $local_num_cols - 1)) ]]; then
                echo $value
            else
                echo -en "$value\t"
            fi
        done
    done
}

# Writes an array to stdout using the first argument as a delimiter
print_array() {
    local IFS="$1"; shift; echo "$*";
}

# Writes the row stats to stdout
print_row_stats() {
    echo "Average Median"
    for ((row=0;row<num_rows;++row)); do
        echo -e "${averages[row]}\t${averages[row]}"
    done
}

# Writes the column stats to stdout
print_col_stats() {
    echo "Averages:"
    print_array $'\t' ${averages[*]}
    echo "Medians:"
    print_array $'\t' ${averages[*]}
}

# If the number of args is not one or two then call the usage function
if [[ !($# -eq 1 || $# -eq 2) ]]; then
    usage
fi

# Determine whether or not row or column stats should be calculated, or call
# the usage function if this cannot be determined
if [[ $1 == -r* ]]; then
    calc_row_stats=true
elif [[ $1 == -c* ]]; then
    calc_row_stats=false
else
    usage
fi

# If a file is provided, but it does not exist or is not a regular file write
# an error message to stderr and exit
if [[ $# -eq 2 && !(-f $2) ]]; then
    echo "Usage: \"$2\" does not exist or is not a reqular file" >&2
    exit 1
fi

# Read the matrix from a file if one is provided. Otherwise, read the matrix
# from standard input.
read_matrix "${2:-/dev/stdin}"

if [[ $calc_row_stats = true ]]; then
    calc_row_averages
    print_row_stats
else
    calc_col_averages
    print_col_stats
fi

exit
